#include <vector>
#include <cmath>
#include <iostream>
#include <string>
#include <numbers>
#include <thread>
#include <random>
#include <chrono>
#include <mutex>

#include "icosaherdron/ico_generator.h"	//generates the icosahedron
#include "Sequence.h"
#include "Utils.h"
#include "Capsid.h"
#include "Files.h"
#include "Optimize.h"



namespace ch = std::chrono;

void usage(const char* invalid);

i_t_ zero_check(const char* name, const char* val);

int main(int argv, char** argc)
{
    double MaxC0 = 10.0;
    double MaxCt = 10.0;
    double CStep = 0.1;
    u_t_ N       = 3; // Default
    u_t_ qpoints = 20;
    std::string method{ "NCG" };

    //Todo: Remove RunMC in the future
    bool RunMC = false;

    //Todo: Get a better commandline parser
    for (int arg = 1; arg < argv; ++arg)
    {
        std::string_view opt(argc[arg]);
        if (opt.compare("-N") == 0)
        {
            arg++;
            N = static_cast<u_t_>(zero_check("N", argc[arg]));
        }
        else if (opt.compare("-C0") == 0)
        {
            arg++;
            MaxC0 = std::abs(std::stod(argc[arg]));
        }
        else if (opt.compare("-Ct") == 0)
        {
            arg++;
            MaxCt = std::abs(std::stod(argc[arg]));
        }
        else if (opt.compare("S") == 0)
        {
            arg++;
            CStep = std::abs(std::stod(argc[arg]));
        }
        else if (opt.compare("-Q") == 0)
        {
            arg++;
            qpoints = static_cast<u_t_>(zero_check("Q", argc[arg]));
        }
        else if (opt.compare("-MC") == 0)
        {
            RunMC = true;
        }
        else if (opt.compare("-M") == 0)
        {
            arg++;
            method = argc[arg];
        }
        else
        {
            usage(argc[arg]);
        }
    }
    // Total number of m and n values in the array
    u_t_ NMode   = capsid::EnergyModes(N);
    u_t_ NPoints = qpoints * qpoints;

    std::cout << "Initial parameters:"
        << "\n    Harmonics degree: " << N
        << "\n    Energy modes: " << NMode
        << "\n    Number of points: " << NPoints
        << '\n';

    
    // Generate icosahedron
    int ico_points = 400;
    auto ico_vertex = generate_icosahedron_surface_points(ico_points);
    //Output icosahedron
    std::ofstream ofs("icoVertices.xyz");
    ofs << ico_vertex.size() << "\ntest\n";
    for (const auto& p : ico_vertex) {
        ofs << 0 << " " << p.x << " " << p.y << " " << p.z << "\n";
    }
	
    //define Capsid object with the give parameters
    capsid::Harmonics h(qpoints, NMode);

    
    std::uniform_real_distribution<double> dist(0.0, 0.5);
    for (auto& a_ : h.a)
    {
      a_ = dist(capsid::Generator());
    }

    h.C0 = 1.0;
    h.a[0] = 2.0 * std::sqrt(std::numbers::pi);
    h.a[1] = 2.0;
   
    
    const auto K = capsid::Calculate_MeanCurve(h);
    capsid::SaveRadii(h, "Initial.xyz");
    
    if (RunMC)
    {
        const fs::path fname{ "minimization_MC.xyz" };
        const auto start{ ch::high_resolution_clock::now() };

        // Randomly generate a coefficients for minimization
        // drawn from a uniform real distribution
        //std::uniform_real_distribution<double> dist(0.0, .1);
        //for (auto& a_ : h.a)
        //{
        //    a_ = dist(capsid::Generator());
        //}
        //h.C0 = 1.0;
        //h.a[0] = 2.0 * std::sqrt(std::numbers::pi);
	
        //h.a[0]=1.0;
        optimize(h, "MC");

        const auto end{ ch::high_resolution_clock::now() };
        std::cout << "Monte Carlo minimization complete. Took: " << ch::duration_cast<ch::milliseconds>(end-start) << '\n';
        std::cout << "Saving results to " << (fs::current_path() / fname).string() << '\n';

        capsid::SaveRadii(h, fname);
    }
    
    
    std::cout << "Results:"
        << "\n    Analytical Gauss-Bonnet: " << 4 * std::numbers::pi
        << "\n    Calculated Gauss-Bonnet: " << K
        << '\n';

/*
    const auto nthreads = std::thread::hardware_concurrency() - 1;

    std::cout << "\nRunning sampler on " << nthreads << " threads...\n";

    Sequence seq(MaxC0, MaxCt, CStep);
    std::mutex mt;
    std::vector<std::thread> threads(nthreads);

    // Multithreaded sampling.
    // Jobs are generated by the sequence generator.
    // Threads that aren't busy will automatically grab their next job off the queue
    //  and start running an optimization routine.
    for (unsigned n = 0; n < nthreads; ++n)
    {
        threads[n] = std::thread([&method, &mt, &NMode, &qpoints, &seq] {
            //Todo: Maybe do harmonics initialization up here for better memory compartmentalization?
            capsid::Harmonics h(qpoints, NMode, true);
            while (true) 
            {
                // Pair {C0,Ct}
                std::pair<double, double> curve;
                {
                    // Temporarily lock threads until we get the next sequence
                    // Avoids race conditions.
                    std::unique_lock<std::mutex> lck(mt);
                    // Exit thread if nothing left to do
                    if (!bool(seq))
                    {
                        return;
                    }
                    curve = *(++seq);
                    //std::println("Thread {} optimizing => [C0 = {:.2f}][Ct = {:.2f}]", std::this_thread::get_id(), curve.first, curve.second);
                }
                h.C0 = curve.first;
                h.Ct = curve.second;
                optimize(h, method);
            }
        });
    }
    for (auto& th : threads)
    {
        th.join();
    }
*/
    return 0;
}

void usage(const char* invalid)
{
    std::cout << "Invalid option: " << invalid 
        << R"(Usage:
    -N:  [+Integer]: Degree of harmonics. (default: 9)
    -Q:  [+Integer]: Number of points to compute. (default: 20)
    -S:  [+Double]:  Step size between curvature values. (default: 0.1)
    -M:              Minimization method. (default: NCG)
    -Ct: [+Double]:  Maximum forced curvature value. (default: 10.0)
    -C0: [+Double]:  Maximum buckling value. (default: 10.0)
)";
    std::exit(-1);
}

i_t_ zero_check(const char* vname, const char* val)
{
    auto l = std::stol(val);
    if (l <= 0)
    {
        std::cout << vname << " must be greater than 0\n";
        usage(vname);
    }
    return l;
}
