#include <vector>
#include <cmath>
#include <iostream>
#include <string>
#include <numbers>
#include <print>
#include <thread>
#include <random>
#include <chrono>
#include <mutex>

#include "Utils.h"
#include "Capsid.h"
#include "Files.h"
#include "Optimize.h"

namespace ch = std::chrono;

void usage(const char* invalid);

i_t_ zero_check(const char* name, const char* val);

int main(int argv, char** argc)
{
    double MaxC0 = 10.0;
    double MaxCt = 10.0;
    double CStep = 0.1;
    u_t_ N       = 3; // Default
    u_t_ qpoints = 100;
    std::string method{ "NCG" };

    //Todo: Remove RunMC in the future
    bool RunMC = false;

    //Todo: Get a better commandline parser
    for (int arg = 1; arg < argv; ++arg)
    {
        std::string_view opt(argc[arg]);
        if (opt.compare("-N") == 0)
        {
            arg++;
            N = static_cast<u_t_>(zero_check("N", argc[arg]));
        }
        else if (opt.compare("-C0") == 0)
        {
            arg++;
            MaxC0 = std::abs(std::stod(argc[arg]));
        }
        else if (opt.compare("-Ct") == 0)
        {
            arg++;
            MaxCt = std::abs(std::stod(argc[arg]));
        }
        else if (opt.compare("S") == 0)
        {
            arg++;
            CStep = std::abs(std::stod(argc[arg]));
        }
        else if (opt.compare("-Q") == 0)
        {
            arg++;
            qpoints = static_cast<u_t_>(zero_check("Q", argc[arg]));
        }
        else if (opt.compare("-MC") == 0)
        {
            RunMC = true;
        }
        else if (opt.compare("-M") == 0)
        {
            arg++;
            method = argc[arg];
        }
        else
        {
            usage(argc[arg]);
        }
    }
    // Total number of m and n values in the array
    u_t_ NMode   = capsid::EnergyModes(N);
    u_t_ NPoints = qpoints * qpoints;

    std::print(R"(Initial parameters:
    Harmonics degree: {}
    Energy modes:     {} 
    Number of points: {}
)", 
        N, NMode, NPoints
    );


    capsid::Harmonics h(qpoints, NMode);

    if (RunMC)
    {
        const fs::path fname{ "mc_min_results.xyz" };
        const auto start{ ch::high_resolution_clock::now() };

        // Randomly generate a coefficients for minimization
        // drawn from a uniform real distribution
        std::uniform_real_distribution<double> dist(0.0, .1);
        for (auto& a_ : h.a)
        {
            a_ = dist(capsid::Generator());
        }
        h.C0 = 2.0;
        h.a[0] = 2.0 * std::sqrt(std::numbers::pi);
        optimize(h, "MC");

        const auto end{ ch::high_resolution_clock::now() };
        std::println("Monte Carlo minimization complete. Took: {}", ch::duration_cast<ch::milliseconds>(end-start));
        std::println("Saving results to {}", (fs::current_path() / fname).string());

        capsid::SaveRadii(h, fname);
    }
    // Reset `a` vector
    ///*
    //std::fill(h.a.begin(), h.a.end(), 0);
    //h.a = capsid::randn(NMode);
    std::uniform_real_distribution<double> dist(0.0, .1);
    for (auto& a_ : h.a)
    {
        a_ = dist(capsid::Generator());
    }
    // Initial object is a single sphere (spherical harmonics sphere)
    h.a[5] = 2.0 * std::sqrt(std::numbers::pi);
    
    const auto K = capsid::Calculate_MeanCurve(h);
    capsid::SaveRadii(h, "test.xyz");

    std::print(R"(
Results:
    Analytical Gauss-Bonnet: {},
    Calculated Gauss-Bonnet: {},
)", 4 * std::numbers::pi, K);
    //*/

    const auto nthreads = std::thread::hardware_concurrency() - 1;

    std::println("\nRunning sampler on {} threads...", nthreads);

    Sequence seq(MaxC0, MaxCt, CStep);
    std::mutex mt;
    std::vector<std::thread> threads(nthreads);

    // Multithreaded sampling.
    // Jobs are generated by the sequence generator.
    // Threads that aren't busy will automatically grab their next job off the queue
    //  and start running an optimization routine.
    for (unsigned n = 0; n < nthreads; ++n)
    {
        threads[n] = std::thread([&method, &mt, &NMode, &qpoints, &seq] {
            //Todo: Maybe do harmonics initialization up here for better memory compartmentalization?
            capsid::Harmonics h(qpoints, NMode, true);
            while (true) 
            {
                // Pair {C0,Ct}
                std::pair<double, double> curve;
                {
                    // Temporarily lock threads until we get the next sequence
                    // Avoids race conditions.
                    std::unique_lock<std::mutex> lck(mt);
                    // Exit thread if nothing left to do
                    if (!bool(seq))
                    {
                        return;
                    }
                    curve = *(++seq);
                    //std::println("Thread {} optimizing => [C0 = {:.2f}][Ct = {:.2f}]", std::this_thread::get_id(), curve.first, curve.second);
                }
                h.C0 = curve.first;
                h.Ct = curve.second;
                optimize(h, method);
            }
        });
    }
    for (auto& th : threads)
    {
        th.join();
    }
    return 0;
}

void usage(const char* invalid)
{
    std::print(R"(Invalid option: {}
Usage: 
    -N:  [+Integer]: Degree of harmonics. (default: 9)
    -Q:  [+Integer]: Number of points to compute. (default: 20)
    -S:  [+Double]:  Step size between curvature values. (default: 0.1)
    -M:              Minimization method. (default: NCG)
    -Ct: [+Double]:  Maximum forced curvature value. (default: 10.0)
    -C0: [+Double]:  Maximum buckling value. (default: 10.0)
)", invalid);
    std::exit(-1);
}

i_t_ zero_check(const char* vname, const char* val)
{
    auto l = std::stol(val);
    if (l <= 0)
    {
        std::println("{} must be greater than 0", vname);
        usage(vname);
    }
    return l;
}
